export default "precision mediump float;\n\nuniform float deltaTime;\nuniform vec3 velocity;\nuniform sampler2D textureDirection; // Texture contenant la direction de déplacement de chaque particule\nuniform vec3 mousePosFront; // Position de la souris dans l'espace 3D pour Z proche de la caméra\nuniform vec3 mousePosBack; // Position de la souris dans l'espace 3D pour Z loin de la caméra\nuniform vec2 mouseVelocity;\n\nvec3 linePlaneIntersection(vec3 lineA, vec3 lineB, float planeZ) {\n    vec3 lineDirection = lineB - lineA;\n    vec3 planeNormal = vec3(0.0, 0.0, -1.0);\n\n    float dotProduct = dot(planeNormal, lineDirection);\n    if(abs(dotProduct) < 0.0001) {\n        return vec3(0.0);\n    }\n\n    float distance = dot(planeNormal, vec3(0.0, 0.0, planeZ) - lineA) / dotProduct;\n    vec3 intersectionPoint = lineA + lineDirection * distance;\n\n    return intersectionPoint;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    // Onn récupère la position actuelle et la direction\n    vec4 previousPos = texture2D(texturePosition, uv);\n    vec4 direction = texture2D(textureDirection, uv);\n\n    // On calcule la nouvelle position\n    vec4 velocityOffset = vec4(velocity, 1.0);\n    vec4 position = previousPos + direction * deltaTime * 0.1 + velocityOffset;\n\n    // On calcule la position de la souris sur le Z de la particule\n    vec3 mousePosition = linePlaneIntersection(mousePosFront, mousePosBack, position.z);\n    // On obtient la distance et la direction entre la particule et la souris\n    vec3 particleToMouse = position.xyz - mousePosition;\n    vec3 dir = normalize(particleToMouse);\n    float dist = length(particleToMouse) * 0.7;\n\n    // On calcule une répulsion qui décroit avec le carré de la distance\n    float repulsion = clamp(0.003 / (dist * dist), 0., 0.1);\n\n    // On fusionne la vélocité de la souris et la vélocité du scroll\n    vec2 mergedVelocity = mouseVelocity * 0.5;\n    mergedVelocity.x += velocity.x;\n    mergedVelocity.y += velocity.y;\n\n    // On calcule la force de répulsion de manière à ce que la souris pousse un peu devant elle et beaucoup sur les côtés\n    vec2 force = vec2((abs(mergedVelocity.x) * repulsion * 0.4) + (abs(mergedVelocity.y) * repulsion * 2.5), (abs(mergedVelocity.y) * repulsion * 0.4) + (abs(mergedVelocity.x) * repulsion * 2.5)) * 150.0;\n\n    // On calcule la position influencée par la force\n    vec4 targetPosition = vec4(position.xyz + vec3(dir.x * force.x, dir.y * force.y, 0.0), position.x);\n\n    // On ajoute la direction de la souris pour créer un peu de \"courant\"\n    targetPosition.x += mouseVelocity.x * 100.0 * repulsion;\n    targetPosition.y += mouseVelocity.y * 100.0 * repulsion;\n\n    // On lerp cette position pour adoucir le mouvement\n    position = mix(position, targetPosition, 0.1);\n\n    // La vélocité de la souris a une très légère influence sur l'ensemble des particules\n    position.x += (mouseVelocity.x * 0.01);\n    position.y += (mouseVelocity.y * 0.01);\n\n   // On empêche les particules de quitter l'écran\n    position.x = mod(position.x + RANGEX, 2.0 * RANGEX) - RANGEX;\n    position.y = mod(position.y + RANGEY, 2.0 * RANGEY) - RANGEY;\n    position.z = mod(position.z + RANGEZ, 2.0 * RANGEZ) - RANGEZ;\n\n    // On inscrit la position dans la couleur pour être lue ensuite par le vertex shader des particules\n    gl_FragColor = position;\n}\n"